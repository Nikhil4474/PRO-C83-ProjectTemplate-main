{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport invariant from \"../utils/invariant\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport * as NavigationActions from \"../NavigationActions\";\nimport * as SwitchActions from \"./SwitchActions\";\nimport * as StackActions from \"./StackActions\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport { createPathParser } from \"./pathUtils\";\n\nvar defaultActionCreators = function defaultActionCreators() {\n  return {};\n};\n\nexport default (function (routeConfigs) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var order = config.order || Object.keys(routeConfigs);\n  var getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  var initialRouteParams = config.initialRouteParams;\n  var initialRouteName = config.initialRouteName || order[0];\n  var backBehavior = config.backBehavior || 'none';\n  var resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  var initialRouteIndex = order.indexOf(initialRouteName);\n\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\" + initialRouteName + \"'.\" + (\"Should be one of \" + order.map(function (n) {\n      return \"\\\"\" + n + \"\\\"\";\n    }).join(', ')));\n  }\n\n  var childRouters = {};\n  order.forEach(function (routeName) {\n    childRouters[routeName] = null;\n    var screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    var routeConfig = routeConfigs[routeName];\n\n    if (routeConfig && routeConfig.params) {\n      return _objectSpread({}, routeConfig.params, params);\n    } else {\n      return params;\n    }\n  }\n\n  var _createPathParser = createPathParser(childRouters, routeConfigs, config),\n      getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n      _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n\n  function resetChildRoute(routeName) {\n    var initialParams = routeName === initialRouteName ? initialRouteParams : undefined;\n    var params = getParamsForRoute(routeName, initialParams);\n    var childRouter = childRouters[routeName];\n\n    if (childRouter) {\n      var childAction = NavigationActions.init();\n      return _objectSpread({}, childRouter.getStateForAction(childAction), {\n        key: routeName,\n        routeName: routeName,\n        params: params\n      });\n    }\n\n    return {\n      key: routeName,\n      routeName: routeName,\n      params: params\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (backBehavior !== 'history' || prevState && nextState && nextState.index === prevState.index) {\n        return nextState;\n      }\n\n      var nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = _toConsumableArray(nextRouteKeyHistory);\n        var keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(function (k) {\n          return k !== keyToAdd;\n        });\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = _toConsumableArray(nextRouteKeyHistory);\n        nextRouteKeyHistory.pop();\n      }\n\n      return _objectSpread({}, nextState, {\n        routeKeyHistory: nextRouteKeyHistory\n      });\n    }\n\n    var nextState = possibleNextState;\n\n    if (prevState && possibleNextState && prevState.index !== possibleNextState.index && resetOnBlur) {\n      var prevRouteName = prevState.routes[prevState.index].routeName;\n\n      var nextRoutes = _toConsumableArray(possibleNextState.routes);\n\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = _objectSpread({}, possibleNextState, {\n        routes: nextRoutes\n      });\n    }\n\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    var routes = order.map(resetChildRoute);\n    var initialState = {\n      routes: routes,\n      index: initialRouteIndex,\n      isTransitioning: false\n    };\n\n    if (backBehavior === 'history') {\n      var initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n\n    return initialState;\n  }\n\n  return {\n    childRouters: childRouters,\n    getActionCreators: function getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n    getStateForAction: function getStateForAction(action, inputState) {\n      var prevState = inputState ? _objectSpread({}, inputState) : inputState;\n      var state = inputState || getInitialState();\n      var activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        var params = action.params;\n\n        if (params) {\n          state.routes = state.routes.map(function (route) {\n            return _objectSpread({}, route, {\n              params: _objectSpread({}, route.params, params, route.routeName === initialRouteName ? initialRouteParams : null)\n            });\n          });\n        }\n      }\n\n      if (action.type === SwitchActions.JUMP_TO && (action.key == null || action.key === state.key)) {\n        var _params = action.params;\n        var index = state.routes.findIndex(function (route) {\n          return route.routeName === action.routeName;\n        });\n\n        if (index === -1) {\n          throw new Error(\"There is no route named '\" + action.routeName + \"' in the navigator with the key '\" + action.key + \"'.\\n\" + (\"Must be one of: \" + state.routes.map(function (route) {\n            return \"'\" + route.routeName + \"'\";\n          }).join(',')));\n        }\n\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          routes: _params ? state.routes.map(function (route, i) {\n            return i === index ? _objectSpread({}, route, {\n              params: _objectSpread({}, route.params, _params)\n            }) : route;\n          }) : state.routes,\n          index: index\n        }));\n      }\n\n      var activeChildLastState = state.routes[state.index];\n      var activeChildRouter = childRouters[order[state.index]];\n\n      if (activeChildRouter) {\n        var activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n\n        if (!activeChildState && inputState) {\n          return null;\n        }\n\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          var routes = _toConsumableArray(state.routes);\n\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes: routes\n          }));\n        }\n      }\n\n      var isBackEligible = action.key == null || action.key === activeChildLastState.key;\n\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        } else if (isBackEligible && backBehavior === 'history' && state.routeKeyHistory.length > 1) {\n          var routeKey = state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n\n      var didNavigate = false;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find(function (childId, i) {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (didNavigate) {\n          var childState = state.routes[activeChildIndex];\n          var childRouter = childRouters[action.routeName];\n          var newChildState = childState;\n\n          if (action.action && childRouter) {\n            var childStateUpdate = childRouter.getStateForAction(action.action, childState);\n\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = _objectSpread({}, newChildState, {\n              params: _objectSpread({}, newChildState.params || {}, action.params)\n            });\n          }\n\n          if (newChildState !== childState) {\n            var _routes = _toConsumableArray(state.routes);\n\n            _routes[activeChildIndex] = newChildState;\n\n            var nextState = _objectSpread({}, state, {\n              routes: _routes,\n              index: activeChildIndex\n            });\n\n            return getNextState(action, prevState, nextState);\n          } else if (newChildState === childState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n\n        if (lastRoute) {\n          var _params2 = _objectSpread({}, lastRoute.params, action.params);\n\n          var _routes2 = _toConsumableArray(state.routes);\n\n          _routes2[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params: _params2\n          });\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes: _routes2\n          }));\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          index: activeChildIndex\n        }));\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return _objectSpread({}, state);\n      }\n\n      var isActionBackOrPop = action.type === NavigationActions.BACK || action.type === StackActions.POP || action.type === StackActions.POP_TO_TOP;\n      var sendActionToInactiveChildren = !isActionBackOrPop || action.type === NavigationActions.BACK && action.key != null;\n\n      if (sendActionToInactiveChildren) {\n        var _index = state.index;\n        var _routes3 = state.routes;\n        order.find(function (childId, i) {\n          var childRouter = childRouters[childId];\n\n          if (i === _index) {\n            return false;\n          }\n\n          var childState = _routes3[i];\n\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n\n          if (!childState) {\n            _index = i;\n            return true;\n          }\n\n          if (childState !== _routes3[i]) {\n            _routes3 = _toConsumableArray(_routes3);\n            _routes3[i] = childState;\n            _index = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (action.preserveFocus) {\n          _index = state.index;\n        }\n\n        if (_index !== state.index || _routes3 !== state.routes) {\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            index: _index,\n            routes: _routes3\n          }));\n        }\n      }\n\n      return state;\n    },\n    getComponentForState: function getComponentForState(state) {\n      var routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \" + state.index + \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\");\n      var childRouter = childRouters[routeName];\n\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return _getActionForPathAndParams(path, params);\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, config.defaultNavigationOptions)\n  };\n});","map":{"version":3,"sources":["SwitchRouter.js"],"names":["defaultActionCreators","config","validateRouteConfigMap","order","Object","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","initialRouteIndex","childRouters","screen","getScreenForRouteName","routeConfig","routeConfigs","getPathAndParamsForRoute","getActionForPathAndParams","createPathParser","initialParams","routeName","params","getParamsForRoute","childRouter","childAction","NavigationActions","key","prevState","nextState","nextRouteKeyHistory","action","keyToAdd","k","routeKeyHistory","possibleNextState","prevRouteName","nextRoutes","resetChildRoute","routes","updateNextStateHistory","initialState","index","isTransitioning","initialKey","getActionCreators","getStateForAction","inputState","state","getInitialState","activeChildIndex","route","SwitchActions","getNextState","i","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","Math","routeKey","didNavigate","childId","childState","newChildState","childStateUpdate","lastRoute","isActionBackOrPop","StackActions","sendActionToInactiveChildren","getComponentForState","invariant","getComponentForRouteName","getPathAndParamsForState","getScreenOptions","createConfigGetter"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport * as NavigationActions from '../NavigationActions';\nimport * as SwitchActions from './SwitchActions';\nimport * as StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n\n  const getCustomActionCreators =\n    config.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map(n => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  const childRouters = {};\n  order.forEach(routeName => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...params };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams =\n      routeName === initialRouteName ? initialRouteParams : undefined;\n    // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        params,\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      params,\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (\n        backBehavior !== 'history' ||\n        (prevState && nextState && nextState.index === prevState.index)\n      ) {\n        return nextState;\n      }\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(k => k !== keyToAdd); // dedup\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        nextRouteKeyHistory.pop();\n      }\n      return {\n        ...nextState,\n        routeKeyHistory: nextRouteKeyHistory,\n      };\n    }\n\n    let nextState = possibleNextState;\n    if (\n      prevState &&\n      possibleNextState &&\n      prevState.index !== possibleNextState.index &&\n      resetOnBlur\n    ) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = {\n        ...possibleNextState,\n        routes: nextRoutes,\n      };\n    }\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex,\n      isTransitioning: false,\n    };\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map(route => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      if (\n        action.type === SwitchActions.JUMP_TO &&\n        (action.key == null || action.key === state.key)\n      ) {\n        const { params } = action;\n        const index = state.routes.findIndex(\n          route => route.routeName === action.routeName\n        );\n\n        if (index === -1) {\n          throw new Error(\n            `There is no route named '${\n              action.routeName\n            }' in the navigator with the key '${action.key}'.\\n` +\n              `Must be one of: ${state.routes\n                .map(route => `'${route.routeName}'`)\n                .join(',')}`\n          );\n        }\n\n        return getNextState(action, prevState, {\n          ...state,\n          routes: params\n            ? state.routes.map((route, i) =>\n                i === index\n                  ? {\n                      ...route,\n                      params: {\n                        ...route.params,\n                        ...params,\n                      },\n                    }\n                  : route\n              )\n            : state.routes,\n          index,\n        });\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      const isBackEligible =\n        action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        }\n        // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (\n          isBackEligible &&\n          backBehavior === 'history' &&\n          state.routeKeyHistory.length > 1\n        ) {\n          const routeKey =\n            state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(\n              action.action,\n              childState\n            );\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = {\n              ...newChildState,\n              params: {\n                ...(newChildState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (\n            newChildState === childState &&\n            state.index === activeChildIndex &&\n            prevState\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state };\n      }\n\n      const isActionBackOrPop =\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP ||\n        action.type === StackActions.POP_TO_TOP;\n      const sendActionToInactiveChildren =\n        !isActionBackOrPop ||\n        (action.type === NavigationActions.BACK && action.key != null);\n\n      // Let other children handle it and switch to the first child that returns a new state\n      // Do not do this for StackActions.POP or NavigationActions.BACK actions without a key:\n      // it would be unintuitive for these actions to switch to another tab just because that tab had a Stack that could accept a back action\n      if (sendActionToInactiveChildren) {\n        let index = state.index;\n        let routes = state.routes;\n        order.find((childId, i) => {\n          const childRouter = childRouters[childId];\n          if (i === index) {\n            return false;\n          }\n          let childState = routes[i];\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n          if (!childState) {\n            index = i;\n            return true;\n          }\n          if (childState !== routes[i]) {\n            routes = [...routes];\n            routes[i] = childState;\n            index = i;\n            return true;\n          }\n          return false;\n        });\n\n        // Nested routers can be updated after switching children with actions such as SET_PARAMS\n        // and COMPLETE_TRANSITION.\n        if (action.preserveFocus) {\n          index = state.index;\n        }\n\n        if (index !== state.index || routes !== state.routes) {\n          return getNextState(action, prevState, {\n            ...state,\n            index,\n            routes,\n          });\n        }\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.defaultNavigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}